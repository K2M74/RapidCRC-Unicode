/***************************************************************************
 Copyright 2004 Sebastian Ewert

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

***************************************************************************/

#include "resource.h"
#include "globals.h"
#include <shlobj.h>

BOOL InterpretSFVLine(TCHAR *szLine, UINT uiStringLength, lFILEINFO *fileList, UINT uiHashMode);
BOOL InterpretMDSHALine(TCHAR *szLine, UINT uiStringLength, UINT uiMode, lFILEINFO *fileList);
BOOL InterpretBSDLine(TCHAR *szLine, UINT uiStringLength, lFILEINFO *fileList);

/*****************************************************************************
DWORD WriteSfvHeader(CONST HANDLE hFile)
hFile		: (IN) handle to an open file

Return Value:
- returns NOERROR or GetLastError()
*****************************************************************************/
DWORD WriteSfvHeader(CONST HANDLE hFile)
{
	TCHAR szLine[MAX_LINE_LENGTH];
#ifdef UNICODE
	CHAR szLineAnsi[MAX_LINE_LENGTH];
#endif
	DWORD dwNumberOfBytesWritten;
	size_t stStringLength;
	VOID *szOutLine=szLine;

    StringCbPrintf(szLine, MAX_LINE_LENGTH, TEXT("; Generated by WIN-SFV32 v1 (compatible; RapidCRC http://rapidcrc.sourceforge.net unicode-file mod by OV2)%s;%s"),
		g_program_options.bCreateUnixStyle ? TEXT("\n") : TEXT("\r\n"), g_program_options.bCreateUnixStyle ? TEXT("\n") : TEXT("\r\n"));

    StringCbLength(szLine, MAX_LINE_LENGTH, & stStringLength);

#ifdef UNICODE
    if(!g_program_options.bCreateUnicodeFiles || g_program_options.iUnicodeSaveType == UTF_8 || g_program_options.iUnicodeSaveType==UTF_8_BOM) {
		if(!WideCharToMultiByte(CP_ACP, 0, szLine, -1, szLineAnsi, MAX_UTF8_PATH, NULL, NULL) )
			return GetLastError();

        StringCbLengthA(szLineAnsi, MAX_LINE_LENGTH, & stStringLength);
		szOutLine=szLineAnsi;
	}
#endif

	if(!WriteFile(hFile, szOutLine, (DWORD)stStringLength, & dwNumberOfBytesWritten, NULL) )
		return GetLastError();

	return NOERROR;
}

/*****************************************************************************
DWORD WriteHashLine(CONST HANDLE hFile, CONST TCHAR szFilename[MAX_PATH_EX], CONST TCHAR szHashResult[RESULT_AS_STRING_MAX_LENGTH], UINT uiMode)
	hFile		    : (IN) handle to an open file
	szFilename	    : (IN) string of the filename that we want to write into the hash file
	szHashResult	: (IN) string of the hash result
    uiMode          : (IN) type of hash file

Return Value:
- returns NOERROR or GetLastError()
*****************************************************************************/
DWORD WriteHashLine(CONST HANDLE hFile, CONST TCHAR szFilename[MAX_PATH_EX], CONST TCHAR szHashResult[RESULT_AS_STRING_MAX_LENGTH], UINT uiMode)
{
	TCHAR szFilenameTemp[MAX_PATH_EX];
	TCHAR szLine[MAX_LINE_LENGTH];
#ifdef UNICODE
	CHAR szLineAnsi[MAX_LINE_LENGTH];
#endif
	DWORD dwNumberOfBytesWritten;
	size_t stStringLength;
	VOID *szOutLine=szLine;

    if(!RegularFromLongFilename(szFilenameTemp, szFilename)) {
	    if(g_program_options.bCreateUnixStyle)
		    ReplaceChar(szFilenameTemp, MAX_PATH_EX, TEXT('\\'), TEXT('/'));
    }

    if(uiMode == MODE_SFV || uiMode == MODE_CRC32C)
        StringCchPrintf(szLine, MAX_LINE_LENGTH, TEXT("%s %s%s"), szFilenameTemp,
		    szHashResult, g_program_options.bCreateUnixStyle ? TEXT("\n") : TEXT("\r\n"));
	else
	{
		const TCHAR *psz_format = uiMode == MODE_BLAKE3 ? TEXT("%s  %s%s") : TEXT("%s *%s%s");
		StringCchPrintf(szLine, MAX_LINE_LENGTH, psz_format, szHashResult,
			szFilenameTemp, g_program_options.bCreateUnixStyle ? TEXT("\n") : TEXT("\r\n"));
	}

	StringCbLength(szLine, MAX_LINE_LENGTH, & stStringLength);

#ifdef UNICODE
    // we only need the conversion if we don't write unicode data
	if(!g_program_options.bCreateUnicodeFiles) {
		if(!WideCharToMultiByte(CP_ACP, 0, szLine, -1, szLineAnsi, MAX_UTF8_PATH, NULL, NULL) )
			return GetLastError();

		StringCbLengthA(szLineAnsi, MAX_LINE_LENGTH, & stStringLength);
		szOutLine=szLineAnsi;
    } else if(g_program_options.iUnicodeSaveType == UTF_8 || g_program_options.iUnicodeSaveType==UTF_8_BOM) {
		if(!WideCharToMultiByte(CP_UTF8, 0, szLine, -1, szLineAnsi, MAX_UTF8_PATH, NULL, NULL) )
			return GetLastError();

		StringCbLengthA(szLineAnsi, MAX_LINE_LENGTH, & stStringLength);
		szOutLine=szLineAnsi;
	}
#endif

	if(!WriteFile(hFile, szOutLine, (DWORD)stStringLength, & dwNumberOfBytesWritten, NULL) )
		return GetLastError();

	return NOERROR;
}

/*****************************************************************************
BOOL EnterHashMode(lFILEINFO *fileList, UINT uiMode)
	fileList	: (IN/OUT) pointer to the job structure whose files are to be processed
    uiMode      : (IN) type of hash file

Return Value:
returns TRUE if everything went fine. FALSE went something went wrong.

Notes:
- takes fileList->fInfos.front().szFilename as .sha1 file and creates new list entries
  based on that
*****************************************************************************/
BOOL EnterHashMode(lFILEINFO *fileList, UINT uiMode)
{
#ifdef UNICODE
	CHAR	szLineAnsi[MAX_LINE_LENGTH];
#endif
	TCHAR	szLine[MAX_LINE_LENGTH];
	TCHAR	szFilenameHash[MAX_PATH_EX];
	HANDLE	hFile;
	UINT	uiStringLength;
	BOOL	bErrorOccured, bEndOfFile;

	BOOL	fileIsUTF16, bWasAnyAbsolute = FALSE;
    UINT    codePage;
	UNICODE_TYPE detectedBOM;

	FILEINFO fileinfoTmp = {0};

	// save hash filename and path
	// => g_szBasePath in is the path part of the complete filename of the .xyz file
	StringCchCopy(szFilenameHash, MAX_PATH_EX, fileList->fInfos.front().szFilename);
	StringCchCopy(fileList->g_szBasePath, MAX_PATH_EX, szFilenameHash);
	ReduceToPath(fileList->g_szBasePath);

	if(fileList->uiCmdOpts==CMD_REPARENT) {
		TCHAR	szReparentPath[MAX_PATH_EX];
		LPITEMIDLIST iidl=NULL;
		BROWSEINFO bInfo = {0};
		bInfo.lpszTitle = TEXT("Select folder for reparenting");
		bInfo.ulFlags = BIF_RETURNONLYFSDIRS | BIF_USENEWUI;
		bInfo.lpfn = BrowseFolderSetSelProc;
		bInfo.lParam = (LPARAM)(fileList->g_szBasePath + 4);
		if(iidl=SHBrowseForFolder(&bInfo)) {
			SHGetPathFromIDList(iidl,szReparentPath);
			CoTaskMemFree(iidl);
            StringCchPrintf(fileList->g_szBasePath, MAX_PATH_EX, TEXT("\\\\?\\%s\\"),szReparentPath);
            if(fileList->g_szBasePath[lstrlen(fileList->g_szBasePath) - 2] == TEXT('\\'))
                fileList->g_szBasePath[lstrlen(fileList->g_szBasePath) - 1] = TEXT('\0');
		}
	}

	// set mode
	fileList->uiRapidCrcMode = uiMode;

	// free everything we did so far
	fileList->fInfos.clear();

	hFile = CreateFile(szFilenameHash, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN , 0);
	if(hFile == INVALID_HANDLE_VALUE){
		MessageBox(NULL, TEXT("Hash file could not be read"), TEXT("Error"), MB_ICONERROR | MB_OK);
		return FALSE;
	}

    // check for the BOM and read accordingly
	detectedBOM = CheckForBOM(hFile);
	fileIsUTF16 = (detectedBOM == UTF_16LE);
	if(!fileIsUTF16) {
		if(detectedBOM==UTF_8_BOM)
            codePage = CP_UTF8;
        else if(g_program_options.bUseDefaultCP)
			codePage = g_program_options.uiDefaultCP;
		else
			codePage = DetermineFileCP(hFile);
	}

	GetNextLine(hFile, szLine, MAX_LINE_LENGTH, & uiStringLength, &bErrorOccured, &bEndOfFile, fileIsUTF16);

	if(bErrorOccured){
		MessageBox(NULL, TEXT("Hash file could not be read"), TEXT("Error"), MB_ICONERROR | MB_OK);
		return FALSE;
	}

	while( !(bEndOfFile && uiStringLength == 0) ) {

#ifdef UNICODE
        // if we already read unicode characters we don't need the conversion here
		if(!fileIsUTF16) {
			AnsiFromUnicode(szLineAnsi,MAX_LINE_LENGTH,szLine);
			MultiByteToWideChar(codePage,	// ANSI Codepage
				0,						    // we use no flags; ANSI isn't a 'real' MBCC
				szLineAnsi,			    	// the ANSI String
				-1,						    // ANSI String is 0 terminated
				szLine,					    // the UNICODE destination string
				MAX_LINE_LENGTH );		    // size of the UNICODE String in chars
            uiStringLength = lstrlen(szLine);
		}
#endif

        BOOL bWasAbsolute = FALSE;
        switch(uiMode) {
            case MODE_SFV:
            case MODE_CRC32C:
                bWasAbsolute = InterpretSFVLine(szLine, uiStringLength, fileList, uiMode);
                break;
            case MODE_MD5:
            case MODE_SHA1:
            case MODE_SHA256:
            case MODE_SHA512:
            case MODE_SHA3_224:
            case MODE_SHA3_256:
            case MODE_SHA3_512:
            case MODE_BLAKE2SP:
			case MODE_BLAKE3:
                bWasAbsolute = InterpretMDSHALine(szLine, uiStringLength, uiMode, fileList);
                break;
            case MODE_BSD:
                bWasAbsolute = InterpretBSDLine(szLine, uiStringLength, fileList);
                break;
        }

        if(bWasAbsolute)
            bWasAnyAbsolute = TRUE;

		GetNextLine(hFile, szLine, MAX_LINE_LENGTH, & uiStringLength, &bErrorOccured, &bEndOfFile, fileIsUTF16);
		if(bErrorOccured){
			MessageBox(NULL, TEXT("Hash file could not be read"), TEXT("Error"), MB_ICONERROR | MB_OK);
			fileList->fInfos.clear();
			return FALSE;
		}
	}
	CloseHandle(hFile);

    // should no longer be necessary to empty the base path if encountering absolute paths
    /*if(bWasAnyAbsolute)
        fileList->g_szBasePath[0] = TEXT('\0');*/

	return TRUE;
}

BOOL InterpretSFVLine(TCHAR *szLine, UINT uiStringLength, lFILEINFO *fileList, UINT uiHashMode)
{
    BOOL	bCrcOK, bWasAbsolute = FALSE;

    FILEINFO fileinfoTmp = {0};
    fileinfoTmp.parentList=fileList;

    if(uiStringLength < 9)
        return FALSE;

    //delete trailing spaces
	while( (szLine[uiStringLength - 1] == TEXT(' ')) && (uiStringLength > 8) ){
		szLine[uiStringLength - 1] = NULL;
		uiStringLength--;
	}

	if( (szLine[0] != TEXT(';')) && (szLine[0] != TEXT('\0')) ){
		bCrcOK = TRUE;
		for(int i=1; i <= 8; ++i)
			if(! IsLegalHexSymbol(szLine[uiStringLength-i]))
				bCrcOK = FALSE;
		if(bCrcOK){
            fileinfoTmp.hashInfo[uiHashMode].dwFound = HASH_FOUND_FILE;
            fileinfoTmp.hashInfo[uiHashMode].f.dwCrc32Found = HexToDword(szLine + uiStringLength - 8, 8);
			fileinfoTmp.dwError = NOERROR;
		}
		else
			fileinfoTmp.dwError = APPL_ERROR_ILLEGAL_CRC;

		uiStringLength -= 8;
		szLine[uiStringLength] = NULL; // keep only the filename
		//delete trailing spaces
		while( (szLine[uiStringLength - 1] == TEXT(' ')) && (uiStringLength > 0) ){
			szLine[uiStringLength - 1] = NULL;
			uiStringLength--;
		}

        ReplaceChar(szLine, MAX_PATH_EX, TEXT('/'), TEXT('\\'));

        bWasAbsolute = !ConstructCompleteFilename(fileinfoTmp.szFilename, fileList->g_szBasePath, szLine);

		fileList->fInfos.push_back(fileinfoTmp);
	}

    return bWasAbsolute;
}

BOOL InterpretMDSHALine(TCHAR *szLine, UINT uiStringLength, UINT uiMode, lFILEINFO *fileList)
{
    UINT    uiHashLengthChars = g_hash_lengths[uiMode] * 2;
    UINT	uiIndex;
    BOOL	bHashOK, bWasAbsolute = FALSE;

    FILEINFO fileinfoTmp = {0};
    fileinfoTmp.parentList=fileList;

    if(uiStringLength < uiHashLengthChars)
        return FALSE;

    if( IsLegalHexSymbol(szLine[0]) ){
	    bHashOK = TRUE;
	    for(uiIndex=0; uiIndex < uiHashLengthChars; ++uiIndex)
		    if(! IsLegalHexSymbol(szLine[uiIndex]))
			    bHashOK = FALSE;
	    if(bHashOK){
		    fileinfoTmp.hashInfo[uiMode].dwFound = TRUE;
		    for(uiIndex=0; uiIndex < g_hash_lengths[uiMode]; ++uiIndex)
			    *((BYTE *)&fileinfoTmp.hashInfo[uiMode].f + uiIndex) = (BYTE)HexToDword(szLine + uiIndex * 2, 2);
		    fileinfoTmp.dwError = NOERROR;
	    }
	    else
		    fileinfoTmp.dwError = APPL_ERROR_ILLEGAL_CRC;

	    //delete trailing spaces
	    while(szLine[uiStringLength - 1] == TEXT(' ')){
		    szLine[uiStringLength - 1] = NULL;
		    uiStringLength--;
	    }

	    //find leading spaces and '*'
	    uiIndex = uiHashLengthChars; // szLine[uiHashLengthChars] is the first char after the hash
	    while( (uiIndex < uiStringLength) && ((szLine[uiIndex] == TEXT(' ')) || (szLine[uiIndex] == TEXT('*'))) )
		    uiIndex++;

        ReplaceChar(szLine, MAX_PATH_EX, TEXT('/'), TEXT('\\'));

        bWasAbsolute = !ConstructCompleteFilename(fileinfoTmp.szFilename, fileList->g_szBasePath, szLine + uiIndex);

	    fileList->fInfos.push_back(fileinfoTmp);
    }

    return bWasAbsolute;
}

BOOL InterpretBSDLine(TCHAR *szLine, UINT uiStringLength, lFILEINFO *fileList)
{
    BOOL	bHashOK, bWasAbsolute = FALSE;
    int     iHashIndex = -1;

    FILEINFO fileinfoTmp = {0};
    fileinfoTmp.parentList=fileList;

    if(uiStringLength < 5)
        return FALSE;

    for(int i=0; i < NUM_HASH_TYPES; i++) {
        if(!_tcsncmp(szLine, g_hash_names[i], lstrlen(g_hash_names[i]))) {
            iHashIndex = i;
            break;
        }
    }
    if(iHashIndex<0)
        return FALSE;

    TCHAR *szFirstBrace = _tcschr(szLine, TEXT('('));
    TCHAR *szLastBrace = _tcsrchr(szLine, TEXT(')'));
    if(!szFirstBrace || !szLastBrace || szFirstBrace > szLastBrace)
        return FALSE;

    *szLastBrace = TEXT('\0');
    szLastBrace++;

    ReplaceChar(szFirstBrace + 1, MAX_PATH_EX, TEXT('/'), TEXT('\\'));
    bWasAbsolute = !ConstructCompleteFilename(fileinfoTmp.szFilename, fileList->g_szBasePath, szFirstBrace + 1);

    while(!IsLegalHexSymbol(*szLastBrace) && *szLastBrace != TEXT('\0') )
        szLastBrace++;

    UINT    uiHashLengthChars = g_hash_lengths[iHashIndex] * 2;

    if(lstrlen(szLastBrace) < (int)uiHashLengthChars)
        return FALSE;

    FILEINFO *fileInfo = &fileinfoTmp;
    bool alreadyInList = false;
    for(list<FILEINFO>::reverse_iterator it = fileList->fInfos.rbegin(); it != fileList->fInfos.rend(); it++) {
        if(it->szFilename == fileinfoTmp.szFilename) {
            fileInfo = &(*it);
            alreadyInList = true;
            break;
        }
    }

    if( IsLegalHexSymbol(*szLastBrace) ){
	    bHashOK = TRUE;
	    for(UINT uiIndex=0; uiIndex < uiHashLengthChars; ++uiIndex)
		    if(! IsLegalHexSymbol(szLastBrace[uiIndex]))
			    bHashOK = FALSE;
	    if(bHashOK){
		    fileInfo->hashInfo[iHashIndex].dwFound = TRUE;
            if(iHashIndex == HASH_TYPE_CRC32) {
                fileInfo->hashInfo[HASH_TYPE_CRC32].f.dwCrc32Found = HexToDword(szLastBrace, 8);
            } else {
		        for(UINT uiIndex=0; uiIndex < g_hash_lengths[iHashIndex]; ++uiIndex)
			        *((BYTE *)&fileInfo->hashInfo[iHashIndex].f + uiIndex) = (BYTE)HexToDword(szLastBrace + uiIndex * 2, 2);
            }
		    fileInfo->dwError = NOERROR;
	    }
	    else
		    fileInfo->dwError = APPL_ERROR_ILLEGAL_CRC;
        if(!alreadyInList)
	        fileList->fInfos.push_back(fileinfoTmp);
        fileList->bDoCalculate[iHashIndex] = true;
    }

    return bWasAbsolute;
}

/*****************************************************************************
DWORD WriteSfvHeader(CONST HANDLE hFile)
hFile		: (IN) handle to an open file

Return Value:
- returns NOERROR or GetLastError()
*****************************************************************************/
DWORD WriteFileComment(CONST HANDLE hFile, CONST FILEINFO *pFileInfo, UINT startChar)
{
	TCHAR szLine[MAX_LINE_LENGTH];
#ifdef UNICODE
	CHAR szLineAnsi[MAX_LINE_LENGTH];
#endif
	DWORD dwNumberOfBytesWritten;
	size_t stStringLength;
	VOID *szOutLine=szLine;

    SYSTEMTIME st;
    FILETIME ft;
    TCHAR szTimeStamp[50];
	TIME_ZONE_INFORMATION tz;
	DWORD dst = GetTimeZoneInformation(&tz);

    FileTimeToLocalFileTime( &pFileInfo->ftModificationTime, &ft );
    FileTimeToSystemTime( &ft, &st );
    int chars = GetTimeFormat( LOCALE_USER_DEFAULT, 0, &st, TEXT("HH':'mm'.'ss"), szTimeStamp, 50 );
    GetDateFormat( LOCALE_USER_DEFAULT, 0, &st, TEXT("' 'yyyy'-'MM'-'dd"), szTimeStamp + chars - 1, 50 - chars );
    StringCbPrintf(szLine, MAX_LINE_LENGTH, TEXT(";%13I64d  %s (UTC%+d) %s%s"), pFileInfo->qwFilesize, szTimeStamp, -tz.Bias / 60,
		pFileInfo->szFilename.GetString() + startChar, g_program_options.bCreateUnixStyle ? TEXT("\n") : TEXT("\r\n"));
	StringCbLength(szLine, MAX_LINE_LENGTH, & stStringLength);


#ifdef UNICODE
    if(!g_program_options.bCreateUnicodeFiles) {
		if(!WideCharToMultiByte(CP_ACP, 0, szLine, -1, szLineAnsi, MAX_UTF8_PATH, NULL, NULL) )
			return GetLastError();
        StringCbLengthA(szLineAnsi, MAX_LINE_LENGTH, & stStringLength);
		szOutLine=szLineAnsi;
    } else if(g_program_options.iUnicodeSaveType == UTF_8 || g_program_options.iUnicodeSaveType==UTF_8_BOM) {
		if(!WideCharToMultiByte(CP_UTF8, 0, szLine, -1, szLineAnsi, MAX_UTF8_PATH, NULL, NULL) )
			return GetLastError();
		StringCbLengthA(szLineAnsi, MAX_LINE_LENGTH, & stStringLength);
		szOutLine=szLineAnsi;
    }
#endif

	if(!WriteFile(hFile, szOutLine, (DWORD)stStringLength, & dwNumberOfBytesWritten, NULL) )
		return GetLastError();

	return NOERROR;
}

#ifdef UNICODE
/*****************************************************************************
BOOL WriteCurrentBOM(CONST HANDLE hFile)
	hFile	: (IN) handle of the file to write the currently set BOM to

Return Value:
returns TRUE if everything went fine. FALSE went something went wrong.
*****************************************************************************/
BOOL WriteCurrentBOM(CONST HANDLE hFile) {
	DWORD bBOM;
	DWORD bomByteCount;
	DWORD NumberOfBytesWritten;

	if(g_program_options.bCreateUnicodeFiles) {
		switch(g_program_options.iUnicodeSaveType) {
			case UTF_16LE:
				bBOM = 0xFEFF;
				bomByteCount = 2;
				break;
			case UTF_8_BOM:
				bBOM = 0xBFBBEF;
				bomByteCount = 3;
				break;
			default:
				bomByteCount = 0;
		}
        if(!WriteFile(hFile, &bBOM, bomByteCount, &NumberOfBytesWritten, NULL)) {
            CloseHandle(hFile);
            return FALSE;
        }
	}
	return TRUE;
}
#endif
